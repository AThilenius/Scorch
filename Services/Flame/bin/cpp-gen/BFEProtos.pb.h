// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BFEProtos.proto

#ifndef PROTOBUF_BFEProtos_2eproto__INCLUDED
#define PROTOBUF_BFEProtos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace Thilenius {
namespace BFEProtos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_BFEProtos_2eproto();
void protobuf_AssignDesc_BFEProtos_2eproto();
void protobuf_ShutdownFile_BFEProtos_2eproto();

class BFEMessage;
class BFELoadLevelRequest;
class BFELoadLevelResponse;
class BFESparkCommand;
class BFESparkResponse;
class BFEInfoQueryRequest;
class BFEInfoQueryResponse;
class Repository;
class Revision;
class FileDelta;
class LexicalDelta;
class BFETextFile;
class BFECodeSubmitRequest;
class BFECodeSubmitResponse;

enum BFESparkCommand_CommandType {
  BFESparkCommand_CommandType_MOVE_FORWARD = 0,
  BFESparkCommand_CommandType_MOVE_BACKWARD = 1,
  BFESparkCommand_CommandType_MOVE_UP = 2,
  BFESparkCommand_CommandType_MOVE_DOWN = 3,
  BFESparkCommand_CommandType_TURN_LEFT = 4,
  BFESparkCommand_CommandType_TURN_RIGHT = 5
};
bool BFESparkCommand_CommandType_IsValid(int value);
const BFESparkCommand_CommandType BFESparkCommand_CommandType_CommandType_MIN = BFESparkCommand_CommandType_MOVE_FORWARD;
const BFESparkCommand_CommandType BFESparkCommand_CommandType_CommandType_MAX = BFESparkCommand_CommandType_TURN_RIGHT;
const int BFESparkCommand_CommandType_CommandType_ARRAYSIZE = BFESparkCommand_CommandType_CommandType_MAX + 1;

enum FileDelta_ChangeType {
  FileDelta_ChangeType_CREATE = 1,
  FileDelta_ChangeType_MODIFY = 2,
  FileDelta_ChangeType_DELETE = 3
};
bool FileDelta_ChangeType_IsValid(int value);
const FileDelta_ChangeType FileDelta_ChangeType_ChangeType_MIN = FileDelta_ChangeType_CREATE;
const FileDelta_ChangeType FileDelta_ChangeType_ChangeType_MAX = FileDelta_ChangeType_DELETE;
const int FileDelta_ChangeType_ChangeType_ARRAYSIZE = FileDelta_ChangeType_ChangeType_MAX + 1;

// ===================================================================

class BFEMessage : public ::google::protobuf::MessageLite {
 public:
  BFEMessage();
  virtual ~BFEMessage();
  
  BFEMessage(const BFEMessage& from);
  
  inline BFEMessage& operator=(const BFEMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BFEMessage& default_instance();
  
  void Swap(BFEMessage* other);
  
  // implements Message ----------------------------------------------
  
  BFEMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BFEMessage& from);
  void MergeFrom(const BFEMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(BFEMessage)
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.BFEMessage)
 private:
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static BFEMessage* default_instance_;
};
// -------------------------------------------------------------------

class BFELoadLevelRequest : public ::google::protobuf::MessageLite {
 public:
  BFELoadLevelRequest();
  virtual ~BFELoadLevelRequest();
  
  BFELoadLevelRequest(const BFELoadLevelRequest& from);
  
  inline BFELoadLevelRequest& operator=(const BFELoadLevelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BFELoadLevelRequest& default_instance();
  
  void Swap(BFELoadLevelRequest* other);
  
  // implements Message ----------------------------------------------
  
  BFELoadLevelRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BFELoadLevelRequest& from);
  void MergeFrom(const BFELoadLevelRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string auth_token = 1;
  inline bool has_auth_token() const;
  inline void clear_auth_token();
  static const int kAuthTokenFieldNumber = 1;
  inline const ::std::string& auth_token() const;
  inline void set_auth_token(const ::std::string& value);
  inline void set_auth_token(const char* value);
  inline void set_auth_token(const char* value, size_t size);
  inline ::std::string* mutable_auth_token();
  inline ::std::string* release_auth_token();
  
  // required int32 levelNumber = 2;
  inline bool has_levelnumber() const;
  inline void clear_levelnumber();
  static const int kLevelNumberFieldNumber = 2;
  inline ::google::protobuf::int32 levelnumber() const;
  inline void set_levelnumber(::google::protobuf::int32 value);
  
  // optional int32 seed = 3;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 3;
  inline ::google::protobuf::int32 seed() const;
  inline void set_seed(::google::protobuf::int32 value);
  
  static const int kBFELoadLevelRequestExtFieldNumber = 100;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Thilenius::BFEProtos::BFEMessage,
      ::google::protobuf::internal::MessageTypeTraits< ::Thilenius::BFEProtos::BFELoadLevelRequest >, 11, false >
    BFELoadLevelRequest_ext;
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.BFELoadLevelRequest)
 private:
  inline void set_has_auth_token();
  inline void clear_has_auth_token();
  inline void set_has_levelnumber();
  inline void clear_has_levelnumber();
  inline void set_has_seed();
  inline void clear_has_seed();
  
  ::std::string* auth_token_;
  ::google::protobuf::int32 levelnumber_;
  ::google::protobuf::int32 seed_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static BFELoadLevelRequest* default_instance_;
};
// -------------------------------------------------------------------

class BFELoadLevelResponse : public ::google::protobuf::MessageLite {
 public:
  BFELoadLevelResponse();
  virtual ~BFELoadLevelResponse();
  
  BFELoadLevelResponse(const BFELoadLevelResponse& from);
  
  inline BFELoadLevelResponse& operator=(const BFELoadLevelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BFELoadLevelResponse& default_instance();
  
  void Swap(BFELoadLevelResponse* other);
  
  // implements Message ----------------------------------------------
  
  BFELoadLevelResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BFELoadLevelResponse& from);
  void MergeFrom(const BFELoadLevelResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string failure_reason = 1;
  inline bool has_failure_reason() const;
  inline void clear_failure_reason();
  static const int kFailureReasonFieldNumber = 1;
  inline const ::std::string& failure_reason() const;
  inline void set_failure_reason(const ::std::string& value);
  inline void set_failure_reason(const char* value);
  inline void set_failure_reason(const char* value, size_t size);
  inline ::std::string* mutable_failure_reason();
  inline ::std::string* release_failure_reason();
  
  // optional int32 spark_count = 2;
  inline bool has_spark_count() const;
  inline void clear_spark_count();
  static const int kSparkCountFieldNumber = 2;
  inline ::google::protobuf::int32 spark_count() const;
  inline void set_spark_count(::google::protobuf::int32 value);
  
  static const int kBFELoadLevelResponseExtFieldNumber = 101;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Thilenius::BFEProtos::BFEMessage,
      ::google::protobuf::internal::MessageTypeTraits< ::Thilenius::BFEProtos::BFELoadLevelResponse >, 11, false >
    BFELoadLevelResponse_ext;
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.BFELoadLevelResponse)
 private:
  inline void set_has_failure_reason();
  inline void clear_has_failure_reason();
  inline void set_has_spark_count();
  inline void clear_has_spark_count();
  
  ::std::string* failure_reason_;
  ::google::protobuf::int32 spark_count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static BFELoadLevelResponse* default_instance_;
};
// -------------------------------------------------------------------

class BFESparkCommand : public ::google::protobuf::MessageLite {
 public:
  BFESparkCommand();
  virtual ~BFESparkCommand();
  
  BFESparkCommand(const BFESparkCommand& from);
  
  inline BFESparkCommand& operator=(const BFESparkCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BFESparkCommand& default_instance();
  
  void Swap(BFESparkCommand* other);
  
  // implements Message ----------------------------------------------
  
  BFESparkCommand* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BFESparkCommand& from);
  void MergeFrom(const BFESparkCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef BFESparkCommand_CommandType CommandType;
  static const CommandType MOVE_FORWARD = BFESparkCommand_CommandType_MOVE_FORWARD;
  static const CommandType MOVE_BACKWARD = BFESparkCommand_CommandType_MOVE_BACKWARD;
  static const CommandType MOVE_UP = BFESparkCommand_CommandType_MOVE_UP;
  static const CommandType MOVE_DOWN = BFESparkCommand_CommandType_MOVE_DOWN;
  static const CommandType TURN_LEFT = BFESparkCommand_CommandType_TURN_LEFT;
  static const CommandType TURN_RIGHT = BFESparkCommand_CommandType_TURN_RIGHT;
  static inline bool CommandType_IsValid(int value) {
    return BFESparkCommand_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    BFESparkCommand_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    BFESparkCommand_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    BFESparkCommand_CommandType_CommandType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .Thilenius.BFEProtos.BFESparkCommand.CommandType command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline ::Thilenius::BFEProtos::BFESparkCommand_CommandType command() const;
  inline void set_command(::Thilenius::BFEProtos::BFESparkCommand_CommandType value);
  
  // required int32 spark_id = 2;
  inline bool has_spark_id() const;
  inline void clear_spark_id();
  static const int kSparkIdFieldNumber = 2;
  inline ::google::protobuf::int32 spark_id() const;
  inline void set_spark_id(::google::protobuf::int32 value);
  
  // required string auth_token = 3;
  inline bool has_auth_token() const;
  inline void clear_auth_token();
  static const int kAuthTokenFieldNumber = 3;
  inline const ::std::string& auth_token() const;
  inline void set_auth_token(const ::std::string& value);
  inline void set_auth_token(const char* value);
  inline void set_auth_token(const char* value, size_t size);
  inline ::std::string* mutable_auth_token();
  inline ::std::string* release_auth_token();
  
  // optional string pipline_token = 4;
  inline bool has_pipline_token() const;
  inline void clear_pipline_token();
  static const int kPiplineTokenFieldNumber = 4;
  inline const ::std::string& pipline_token() const;
  inline void set_pipline_token(const ::std::string& value);
  inline void set_pipline_token(const char* value);
  inline void set_pipline_token(const char* value, size_t size);
  inline ::std::string* mutable_pipline_token();
  inline ::std::string* release_pipline_token();
  
  static const int kBFESparkCommandExtFieldNumber = 102;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Thilenius::BFEProtos::BFEMessage,
      ::google::protobuf::internal::MessageTypeTraits< ::Thilenius::BFEProtos::BFESparkCommand >, 11, false >
    BFESparkCommand_ext;
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.BFESparkCommand)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_spark_id();
  inline void clear_has_spark_id();
  inline void set_has_auth_token();
  inline void clear_has_auth_token();
  inline void set_has_pipline_token();
  inline void clear_has_pipline_token();
  
  int command_;
  ::google::protobuf::int32 spark_id_;
  ::std::string* auth_token_;
  ::std::string* pipline_token_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static BFESparkCommand* default_instance_;
};
// -------------------------------------------------------------------

class BFESparkResponse : public ::google::protobuf::MessageLite {
 public:
  BFESparkResponse();
  virtual ~BFESparkResponse();
  
  BFESparkResponse(const BFESparkResponse& from);
  
  inline BFESparkResponse& operator=(const BFESparkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BFESparkResponse& default_instance();
  
  void Swap(BFESparkResponse* other);
  
  // implements Message ----------------------------------------------
  
  BFESparkResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BFESparkResponse& from);
  void MergeFrom(const BFESparkResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string pipline_token = 1;
  inline bool has_pipline_token() const;
  inline void clear_pipline_token();
  static const int kPiplineTokenFieldNumber = 1;
  inline const ::std::string& pipline_token() const;
  inline void set_pipline_token(const ::std::string& value);
  inline void set_pipline_token(const char* value);
  inline void set_pipline_token(const char* value, size_t size);
  inline ::std::string* mutable_pipline_token();
  inline ::std::string* release_pipline_token();
  
  // optional string failure_reason = 2;
  inline bool has_failure_reason() const;
  inline void clear_failure_reason();
  static const int kFailureReasonFieldNumber = 2;
  inline const ::std::string& failure_reason() const;
  inline void set_failure_reason(const ::std::string& value);
  inline void set_failure_reason(const char* value);
  inline void set_failure_reason(const char* value, size_t size);
  inline ::std::string* mutable_failure_reason();
  inline ::std::string* release_failure_reason();
  
  // optional bool response_bool = 3;
  inline bool has_response_bool() const;
  inline void clear_response_bool();
  static const int kResponseBoolFieldNumber = 3;
  inline bool response_bool() const;
  inline void set_response_bool(bool value);
  
  // optional int32 response_int = 4;
  inline bool has_response_int() const;
  inline void clear_response_int();
  static const int kResponseIntFieldNumber = 4;
  inline ::google::protobuf::int32 response_int() const;
  inline void set_response_int(::google::protobuf::int32 value);
  
  // optional float response_float = 5;
  inline bool has_response_float() const;
  inline void clear_response_float();
  static const int kResponseFloatFieldNumber = 5;
  inline float response_float() const;
  inline void set_response_float(float value);
  
  // optional bytes response_bytes = 6;
  inline bool has_response_bytes() const;
  inline void clear_response_bytes();
  static const int kResponseBytesFieldNumber = 6;
  inline const ::std::string& response_bytes() const;
  inline void set_response_bytes(const ::std::string& value);
  inline void set_response_bytes(const char* value);
  inline void set_response_bytes(const void* value, size_t size);
  inline ::std::string* mutable_response_bytes();
  inline ::std::string* release_response_bytes();
  
  static const int kBFESparkResponseExtFieldNumber = 103;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Thilenius::BFEProtos::BFEMessage,
      ::google::protobuf::internal::MessageTypeTraits< ::Thilenius::BFEProtos::BFESparkResponse >, 11, false >
    BFESparkResponse_ext;
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.BFESparkResponse)
 private:
  inline void set_has_pipline_token();
  inline void clear_has_pipline_token();
  inline void set_has_failure_reason();
  inline void clear_has_failure_reason();
  inline void set_has_response_bool();
  inline void clear_has_response_bool();
  inline void set_has_response_int();
  inline void clear_has_response_int();
  inline void set_has_response_float();
  inline void clear_has_response_float();
  inline void set_has_response_bytes();
  inline void clear_has_response_bytes();
  
  ::std::string* pipline_token_;
  ::std::string* failure_reason_;
  bool response_bool_;
  ::google::protobuf::int32 response_int_;
  ::std::string* response_bytes_;
  float response_float_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static BFESparkResponse* default_instance_;
};
// -------------------------------------------------------------------

class BFEInfoQueryRequest : public ::google::protobuf::MessageLite {
 public:
  BFEInfoQueryRequest();
  virtual ~BFEInfoQueryRequest();
  
  BFEInfoQueryRequest(const BFEInfoQueryRequest& from);
  
  inline BFEInfoQueryRequest& operator=(const BFEInfoQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BFEInfoQueryRequest& default_instance();
  
  void Swap(BFEInfoQueryRequest* other);
  
  // implements Message ----------------------------------------------
  
  BFEInfoQueryRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BFEInfoQueryRequest& from);
  void MergeFrom(const BFEInfoQueryRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string auth_token = 1;
  inline bool has_auth_token() const;
  inline void clear_auth_token();
  static const int kAuthTokenFieldNumber = 1;
  inline const ::std::string& auth_token() const;
  inline void set_auth_token(const ::std::string& value);
  inline void set_auth_token(const char* value);
  inline void set_auth_token(const char* value, size_t size);
  inline ::std::string* mutable_auth_token();
  inline ::std::string* release_auth_token();
  
  static const int kBFEInfoQueryRequestExtFieldNumber = 104;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Thilenius::BFEProtos::BFEMessage,
      ::google::protobuf::internal::MessageTypeTraits< ::Thilenius::BFEProtos::BFEInfoQueryRequest >, 11, false >
    BFEInfoQueryRequest_ext;
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.BFEInfoQueryRequest)
 private:
  inline void set_has_auth_token();
  inline void clear_has_auth_token();
  
  ::std::string* auth_token_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static BFEInfoQueryRequest* default_instance_;
};
// -------------------------------------------------------------------

class BFEInfoQueryResponse : public ::google::protobuf::MessageLite {
 public:
  BFEInfoQueryResponse();
  virtual ~BFEInfoQueryResponse();
  
  BFEInfoQueryResponse(const BFEInfoQueryResponse& from);
  
  inline BFEInfoQueryResponse& operator=(const BFEInfoQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BFEInfoQueryResponse& default_instance();
  
  void Swap(BFEInfoQueryResponse* other);
  
  // implements Message ----------------------------------------------
  
  BFEInfoQueryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BFEInfoQueryResponse& from);
  void MergeFrom(const BFEInfoQueryResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string failure_reason = 1;
  inline bool has_failure_reason() const;
  inline void clear_failure_reason();
  static const int kFailureReasonFieldNumber = 1;
  inline const ::std::string& failure_reason() const;
  inline void set_failure_reason(const ::std::string& value);
  inline void set_failure_reason(const char* value);
  inline void set_failure_reason(const char* value, size_t size);
  inline ::std::string* mutable_failure_reason();
  inline ::std::string* release_failure_reason();
  
  // optional string blaze_response = 2;
  inline bool has_blaze_response() const;
  inline void clear_blaze_response();
  static const int kBlazeResponseFieldNumber = 2;
  inline const ::std::string& blaze_response() const;
  inline void set_blaze_response(const ::std::string& value);
  inline void set_blaze_response(const char* value);
  inline void set_blaze_response(const char* value, size_t size);
  inline ::std::string* mutable_blaze_response();
  inline ::std::string* release_blaze_response();
  
  static const int kBFEInfoQueryResponseExtFieldNumber = 105;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Thilenius::BFEProtos::BFEMessage,
      ::google::protobuf::internal::MessageTypeTraits< ::Thilenius::BFEProtos::BFEInfoQueryResponse >, 11, false >
    BFEInfoQueryResponse_ext;
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.BFEInfoQueryResponse)
 private:
  inline void set_has_failure_reason();
  inline void clear_has_failure_reason();
  inline void set_has_blaze_response();
  inline void clear_has_blaze_response();
  
  ::std::string* failure_reason_;
  ::std::string* blaze_response_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static BFEInfoQueryResponse* default_instance_;
};
// -------------------------------------------------------------------

class Repository : public ::google::protobuf::MessageLite {
 public:
  Repository();
  virtual ~Repository();
  
  Repository(const Repository& from);
  
  inline Repository& operator=(const Repository& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Repository& default_instance();
  
  void Swap(Repository* other);
  
  // implements Message ----------------------------------------------
  
  Repository* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Repository& from);
  void MergeFrom(const Repository& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string repo_uuid = 1;
  inline bool has_repo_uuid() const;
  inline void clear_repo_uuid();
  static const int kRepoUuidFieldNumber = 1;
  inline const ::std::string& repo_uuid() const;
  inline void set_repo_uuid(const ::std::string& value);
  inline void set_repo_uuid(const char* value);
  inline void set_repo_uuid(const char* value, size_t size);
  inline ::std::string* mutable_repo_uuid();
  inline ::std::string* release_repo_uuid();
  
  // repeated .Thilenius.BFEProtos.Revision revisions = 2;
  inline int revisions_size() const;
  inline void clear_revisions();
  static const int kRevisionsFieldNumber = 2;
  inline const ::Thilenius::BFEProtos::Revision& revisions(int index) const;
  inline ::Thilenius::BFEProtos::Revision* mutable_revisions(int index);
  inline ::Thilenius::BFEProtos::Revision* add_revisions();
  inline const ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::Revision >&
      revisions() const;
  inline ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::Revision >*
      mutable_revisions();
  
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.Repository)
 private:
  inline void set_has_repo_uuid();
  inline void clear_has_repo_uuid();
  
  ::std::string* repo_uuid_;
  ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::Revision > revisions_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static Repository* default_instance_;
};
// -------------------------------------------------------------------

class Revision : public ::google::protobuf::MessageLite {
 public:
  Revision();
  virtual ~Revision();
  
  Revision(const Revision& from);
  
  inline Revision& operator=(const Revision& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Revision& default_instance();
  
  void Swap(Revision* other);
  
  // implements Message ----------------------------------------------
  
  Revision* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Revision& from);
  void MergeFrom(const Revision& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string comment = 1;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 1;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  
  // optional string timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // repeated .Thilenius.BFEProtos.FileDelta file_deltas = 3;
  inline int file_deltas_size() const;
  inline void clear_file_deltas();
  static const int kFileDeltasFieldNumber = 3;
  inline const ::Thilenius::BFEProtos::FileDelta& file_deltas(int index) const;
  inline ::Thilenius::BFEProtos::FileDelta* mutable_file_deltas(int index);
  inline ::Thilenius::BFEProtos::FileDelta* add_file_deltas();
  inline const ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::FileDelta >&
      file_deltas() const;
  inline ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::FileDelta >*
      mutable_file_deltas();
  
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.Revision)
 private:
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::std::string* comment_;
  ::std::string* timestamp_;
  ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::FileDelta > file_deltas_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static Revision* default_instance_;
};
// -------------------------------------------------------------------

class FileDelta : public ::google::protobuf::MessageLite {
 public:
  FileDelta();
  virtual ~FileDelta();
  
  FileDelta(const FileDelta& from);
  
  inline FileDelta& operator=(const FileDelta& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FileDelta& default_instance();
  
  void Swap(FileDelta* other);
  
  // implements Message ----------------------------------------------
  
  FileDelta* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileDelta& from);
  void MergeFrom(const FileDelta& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef FileDelta_ChangeType ChangeType;
  static const ChangeType CREATE = FileDelta_ChangeType_CREATE;
  static const ChangeType MODIFY = FileDelta_ChangeType_MODIFY;
  static const ChangeType DELETE = FileDelta_ChangeType_DELETE;
  static inline bool ChangeType_IsValid(int value) {
    return FileDelta_ChangeType_IsValid(value);
  }
  static const ChangeType ChangeType_MIN =
    FileDelta_ChangeType_ChangeType_MIN;
  static const ChangeType ChangeType_MAX =
    FileDelta_ChangeType_ChangeType_MAX;
  static const int ChangeType_ARRAYSIZE =
    FileDelta_ChangeType_ChangeType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // required .Thilenius.BFEProtos.FileDelta.ChangeType change_type = 2;
  inline bool has_change_type() const;
  inline void clear_change_type();
  static const int kChangeTypeFieldNumber = 2;
  inline ::Thilenius::BFEProtos::FileDelta_ChangeType change_type() const;
  inline void set_change_type(::Thilenius::BFEProtos::FileDelta_ChangeType value);
  
  // repeated .Thilenius.BFEProtos.LexicalDelta lexical_deltas = 3;
  inline int lexical_deltas_size() const;
  inline void clear_lexical_deltas();
  static const int kLexicalDeltasFieldNumber = 3;
  inline const ::Thilenius::BFEProtos::LexicalDelta& lexical_deltas(int index) const;
  inline ::Thilenius::BFEProtos::LexicalDelta* mutable_lexical_deltas(int index);
  inline ::Thilenius::BFEProtos::LexicalDelta* add_lexical_deltas();
  inline const ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::LexicalDelta >&
      lexical_deltas() const;
  inline ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::LexicalDelta >*
      mutable_lexical_deltas();
  
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.FileDelta)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_change_type();
  inline void clear_has_change_type();
  
  ::std::string* path_;
  ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::LexicalDelta > lexical_deltas_;
  int change_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static FileDelta* default_instance_;
};
// -------------------------------------------------------------------

class LexicalDelta : public ::google::protobuf::MessageLite {
 public:
  LexicalDelta();
  virtual ~LexicalDelta();
  
  LexicalDelta(const LexicalDelta& from);
  
  inline LexicalDelta& operator=(const LexicalDelta& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const LexicalDelta& default_instance();
  
  void Swap(LexicalDelta* other);
  
  // implements Message ----------------------------------------------
  
  LexicalDelta* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LexicalDelta& from);
  void MergeFrom(const LexicalDelta& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 from_begin = 1;
  inline bool has_from_begin() const;
  inline void clear_from_begin();
  static const int kFromBeginFieldNumber = 1;
  inline ::google::protobuf::int32 from_begin() const;
  inline void set_from_begin(::google::protobuf::int32 value);
  
  // required int32 from_end = 2;
  inline bool has_from_end() const;
  inline void clear_from_end();
  static const int kFromEndFieldNumber = 2;
  inline ::google::protobuf::int32 from_end() const;
  inline void set_from_end(::google::protobuf::int32 value);
  
  // required int32 to_begin = 3;
  inline bool has_to_begin() const;
  inline void clear_to_begin();
  static const int kToBeginFieldNumber = 3;
  inline ::google::protobuf::int32 to_begin() const;
  inline void set_to_begin(::google::protobuf::int32 value);
  
  // required int32 to_end = 4;
  inline bool has_to_end() const;
  inline void clear_to_end();
  static const int kToEndFieldNumber = 4;
  inline ::google::protobuf::int32 to_end() const;
  inline void set_to_end(::google::protobuf::int32 value);
  
  // optional string text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.LexicalDelta)
 private:
  inline void set_has_from_begin();
  inline void clear_has_from_begin();
  inline void set_has_from_end();
  inline void clear_has_from_end();
  inline void set_has_to_begin();
  inline void clear_has_to_begin();
  inline void set_has_to_end();
  inline void clear_has_to_end();
  inline void set_has_text();
  inline void clear_has_text();
  
  ::google::protobuf::int32 from_begin_;
  ::google::protobuf::int32 from_end_;
  ::google::protobuf::int32 to_begin_;
  ::google::protobuf::int32 to_end_;
  ::std::string* text_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static LexicalDelta* default_instance_;
};
// -------------------------------------------------------------------

class BFETextFile : public ::google::protobuf::MessageLite {
 public:
  BFETextFile();
  virtual ~BFETextFile();
  
  BFETextFile(const BFETextFile& from);
  
  inline BFETextFile& operator=(const BFETextFile& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BFETextFile& default_instance();
  
  void Swap(BFETextFile* other);
  
  // implements Message ----------------------------------------------
  
  BFETextFile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BFETextFile& from);
  void MergeFrom(const BFETextFile& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string extension = 2;
  inline bool has_extension() const;
  inline void clear_extension();
  static const int kExtensionFieldNumber = 2;
  inline const ::std::string& extension() const;
  inline void set_extension(const ::std::string& value);
  inline void set_extension(const char* value);
  inline void set_extension(const char* value, size_t size);
  inline ::std::string* mutable_extension();
  inline ::std::string* release_extension();
  
  // optional string modify_date = 3;
  inline bool has_modify_date() const;
  inline void clear_modify_date();
  static const int kModifyDateFieldNumber = 3;
  inline const ::std::string& modify_date() const;
  inline void set_modify_date(const ::std::string& value);
  inline void set_modify_date(const char* value);
  inline void set_modify_date(const char* value, size_t size);
  inline ::std::string* mutable_modify_date();
  inline ::std::string* release_modify_date();
  
  // optional string contents = 4;
  inline bool has_contents() const;
  inline void clear_contents();
  static const int kContentsFieldNumber = 4;
  inline const ::std::string& contents() const;
  inline void set_contents(const ::std::string& value);
  inline void set_contents(const char* value);
  inline void set_contents(const char* value, size_t size);
  inline ::std::string* mutable_contents();
  inline ::std::string* release_contents();
  
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.BFETextFile)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_extension();
  inline void clear_has_extension();
  inline void set_has_modify_date();
  inline void clear_has_modify_date();
  inline void set_has_contents();
  inline void clear_has_contents();
  
  ::std::string* name_;
  ::std::string* extension_;
  ::std::string* modify_date_;
  ::std::string* contents_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static BFETextFile* default_instance_;
};
// -------------------------------------------------------------------

class BFECodeSubmitRequest : public ::google::protobuf::MessageLite {
 public:
  BFECodeSubmitRequest();
  virtual ~BFECodeSubmitRequest();
  
  BFECodeSubmitRequest(const BFECodeSubmitRequest& from);
  
  inline BFECodeSubmitRequest& operator=(const BFECodeSubmitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BFECodeSubmitRequest& default_instance();
  
  void Swap(BFECodeSubmitRequest* other);
  
  // implements Message ----------------------------------------------
  
  BFECodeSubmitRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BFECodeSubmitRequest& from);
  void MergeFrom(const BFECodeSubmitRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string auth_token = 1;
  inline bool has_auth_token() const;
  inline void clear_auth_token();
  static const int kAuthTokenFieldNumber = 1;
  inline const ::std::string& auth_token() const;
  inline void set_auth_token(const ::std::string& value);
  inline void set_auth_token(const char* value);
  inline void set_auth_token(const char* value, size_t size);
  inline ::std::string* mutable_auth_token();
  inline ::std::string* release_auth_token();
  
  // repeated .Thilenius.BFEProtos.BFETextFile code_files = 2;
  inline int code_files_size() const;
  inline void clear_code_files();
  static const int kCodeFilesFieldNumber = 2;
  inline const ::Thilenius::BFEProtos::BFETextFile& code_files(int index) const;
  inline ::Thilenius::BFEProtos::BFETextFile* mutable_code_files(int index);
  inline ::Thilenius::BFEProtos::BFETextFile* add_code_files();
  inline const ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::BFETextFile >&
      code_files() const;
  inline ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::BFETextFile >*
      mutable_code_files();
  
  static const int kBFECodeSubmitRequestExtFieldNumber = 106;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Thilenius::BFEProtos::BFEMessage,
      ::google::protobuf::internal::MessageTypeTraits< ::Thilenius::BFEProtos::BFECodeSubmitRequest >, 11, false >
    BFECodeSubmitRequest_ext;
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.BFECodeSubmitRequest)
 private:
  inline void set_has_auth_token();
  inline void clear_has_auth_token();
  
  ::std::string* auth_token_;
  ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::BFETextFile > code_files_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static BFECodeSubmitRequest* default_instance_;
};
// -------------------------------------------------------------------

class BFECodeSubmitResponse : public ::google::protobuf::MessageLite {
 public:
  BFECodeSubmitResponse();
  virtual ~BFECodeSubmitResponse();
  
  BFECodeSubmitResponse(const BFECodeSubmitResponse& from);
  
  inline BFECodeSubmitResponse& operator=(const BFECodeSubmitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BFECodeSubmitResponse& default_instance();
  
  void Swap(BFECodeSubmitResponse* other);
  
  // implements Message ----------------------------------------------
  
  BFECodeSubmitResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BFECodeSubmitResponse& from);
  void MergeFrom(const BFECodeSubmitResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string failure_reason = 1;
  inline bool has_failure_reason() const;
  inline void clear_failure_reason();
  static const int kFailureReasonFieldNumber = 1;
  inline const ::std::string& failure_reason() const;
  inline void set_failure_reason(const ::std::string& value);
  inline void set_failure_reason(const char* value);
  inline void set_failure_reason(const char* value, size_t size);
  inline ::std::string* mutable_failure_reason();
  inline ::std::string* release_failure_reason();
  
  static const int kBFECodeSubmitResponseExtFieldNumber = 107;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Thilenius::BFEProtos::BFEMessage,
      ::google::protobuf::internal::MessageTypeTraits< ::Thilenius::BFEProtos::BFECodeSubmitResponse >, 11, false >
    BFECodeSubmitResponse_ext;
  // @@protoc_insertion_point(class_scope:Thilenius.BFEProtos.BFECodeSubmitResponse)
 private:
  inline void set_has_failure_reason();
  inline void clear_has_failure_reason();
  
  ::std::string* failure_reason_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_BFEProtos_2eproto();
  friend void protobuf_AssignDesc_BFEProtos_2eproto();
  friend void protobuf_ShutdownFile_BFEProtos_2eproto();
  
  void InitAsDefaultInstance();
  static BFECodeSubmitResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// BFEMessage

// -------------------------------------------------------------------

// BFELoadLevelRequest

// required string auth_token = 1;
inline bool BFELoadLevelRequest::has_auth_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BFELoadLevelRequest::set_has_auth_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BFELoadLevelRequest::clear_has_auth_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BFELoadLevelRequest::clear_auth_token() {
  if (auth_token_ != &::google::protobuf::internal::kEmptyString) {
    auth_token_->clear();
  }
  clear_has_auth_token();
}
inline const ::std::string& BFELoadLevelRequest::auth_token() const {
  return *auth_token_;
}
inline void BFELoadLevelRequest::set_auth_token(const ::std::string& value) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(value);
}
inline void BFELoadLevelRequest::set_auth_token(const char* value) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(value);
}
inline void BFELoadLevelRequest::set_auth_token(const char* value, size_t size) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFELoadLevelRequest::mutable_auth_token() {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  return auth_token_;
}
inline ::std::string* BFELoadLevelRequest::release_auth_token() {
  clear_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_token_;
    auth_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 levelNumber = 2;
inline bool BFELoadLevelRequest::has_levelnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BFELoadLevelRequest::set_has_levelnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BFELoadLevelRequest::clear_has_levelnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BFELoadLevelRequest::clear_levelnumber() {
  levelnumber_ = 0;
  clear_has_levelnumber();
}
inline ::google::protobuf::int32 BFELoadLevelRequest::levelnumber() const {
  return levelnumber_;
}
inline void BFELoadLevelRequest::set_levelnumber(::google::protobuf::int32 value) {
  set_has_levelnumber();
  levelnumber_ = value;
}

// optional int32 seed = 3;
inline bool BFELoadLevelRequest::has_seed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BFELoadLevelRequest::set_has_seed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BFELoadLevelRequest::clear_has_seed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BFELoadLevelRequest::clear_seed() {
  seed_ = 0;
  clear_has_seed();
}
inline ::google::protobuf::int32 BFELoadLevelRequest::seed() const {
  return seed_;
}
inline void BFELoadLevelRequest::set_seed(::google::protobuf::int32 value) {
  set_has_seed();
  seed_ = value;
}

// -------------------------------------------------------------------

// BFELoadLevelResponse

// optional string failure_reason = 1;
inline bool BFELoadLevelResponse::has_failure_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BFELoadLevelResponse::set_has_failure_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BFELoadLevelResponse::clear_has_failure_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BFELoadLevelResponse::clear_failure_reason() {
  if (failure_reason_ != &::google::protobuf::internal::kEmptyString) {
    failure_reason_->clear();
  }
  clear_has_failure_reason();
}
inline const ::std::string& BFELoadLevelResponse::failure_reason() const {
  return *failure_reason_;
}
inline void BFELoadLevelResponse::set_failure_reason(const ::std::string& value) {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  failure_reason_->assign(value);
}
inline void BFELoadLevelResponse::set_failure_reason(const char* value) {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  failure_reason_->assign(value);
}
inline void BFELoadLevelResponse::set_failure_reason(const char* value, size_t size) {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  failure_reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFELoadLevelResponse::mutable_failure_reason() {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  return failure_reason_;
}
inline ::std::string* BFELoadLevelResponse::release_failure_reason() {
  clear_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = failure_reason_;
    failure_reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 spark_count = 2;
inline bool BFELoadLevelResponse::has_spark_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BFELoadLevelResponse::set_has_spark_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BFELoadLevelResponse::clear_has_spark_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BFELoadLevelResponse::clear_spark_count() {
  spark_count_ = 0;
  clear_has_spark_count();
}
inline ::google::protobuf::int32 BFELoadLevelResponse::spark_count() const {
  return spark_count_;
}
inline void BFELoadLevelResponse::set_spark_count(::google::protobuf::int32 value) {
  set_has_spark_count();
  spark_count_ = value;
}

// -------------------------------------------------------------------

// BFESparkCommand

// required .Thilenius.BFEProtos.BFESparkCommand.CommandType command = 1;
inline bool BFESparkCommand::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BFESparkCommand::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BFESparkCommand::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BFESparkCommand::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::Thilenius::BFEProtos::BFESparkCommand_CommandType BFESparkCommand::command() const {
  return static_cast< ::Thilenius::BFEProtos::BFESparkCommand_CommandType >(command_);
}
inline void BFESparkCommand::set_command(::Thilenius::BFEProtos::BFESparkCommand_CommandType value) {
  GOOGLE_DCHECK(::Thilenius::BFEProtos::BFESparkCommand_CommandType_IsValid(value));
  set_has_command();
  command_ = value;
}

// required int32 spark_id = 2;
inline bool BFESparkCommand::has_spark_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BFESparkCommand::set_has_spark_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BFESparkCommand::clear_has_spark_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BFESparkCommand::clear_spark_id() {
  spark_id_ = 0;
  clear_has_spark_id();
}
inline ::google::protobuf::int32 BFESparkCommand::spark_id() const {
  return spark_id_;
}
inline void BFESparkCommand::set_spark_id(::google::protobuf::int32 value) {
  set_has_spark_id();
  spark_id_ = value;
}

// required string auth_token = 3;
inline bool BFESparkCommand::has_auth_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BFESparkCommand::set_has_auth_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BFESparkCommand::clear_has_auth_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BFESparkCommand::clear_auth_token() {
  if (auth_token_ != &::google::protobuf::internal::kEmptyString) {
    auth_token_->clear();
  }
  clear_has_auth_token();
}
inline const ::std::string& BFESparkCommand::auth_token() const {
  return *auth_token_;
}
inline void BFESparkCommand::set_auth_token(const ::std::string& value) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(value);
}
inline void BFESparkCommand::set_auth_token(const char* value) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(value);
}
inline void BFESparkCommand::set_auth_token(const char* value, size_t size) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFESparkCommand::mutable_auth_token() {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  return auth_token_;
}
inline ::std::string* BFESparkCommand::release_auth_token() {
  clear_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_token_;
    auth_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string pipline_token = 4;
inline bool BFESparkCommand::has_pipline_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BFESparkCommand::set_has_pipline_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BFESparkCommand::clear_has_pipline_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BFESparkCommand::clear_pipline_token() {
  if (pipline_token_ != &::google::protobuf::internal::kEmptyString) {
    pipline_token_->clear();
  }
  clear_has_pipline_token();
}
inline const ::std::string& BFESparkCommand::pipline_token() const {
  return *pipline_token_;
}
inline void BFESparkCommand::set_pipline_token(const ::std::string& value) {
  set_has_pipline_token();
  if (pipline_token_ == &::google::protobuf::internal::kEmptyString) {
    pipline_token_ = new ::std::string;
  }
  pipline_token_->assign(value);
}
inline void BFESparkCommand::set_pipline_token(const char* value) {
  set_has_pipline_token();
  if (pipline_token_ == &::google::protobuf::internal::kEmptyString) {
    pipline_token_ = new ::std::string;
  }
  pipline_token_->assign(value);
}
inline void BFESparkCommand::set_pipline_token(const char* value, size_t size) {
  set_has_pipline_token();
  if (pipline_token_ == &::google::protobuf::internal::kEmptyString) {
    pipline_token_ = new ::std::string;
  }
  pipline_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFESparkCommand::mutable_pipline_token() {
  set_has_pipline_token();
  if (pipline_token_ == &::google::protobuf::internal::kEmptyString) {
    pipline_token_ = new ::std::string;
  }
  return pipline_token_;
}
inline ::std::string* BFESparkCommand::release_pipline_token() {
  clear_has_pipline_token();
  if (pipline_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pipline_token_;
    pipline_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BFESparkResponse

// optional string pipline_token = 1;
inline bool BFESparkResponse::has_pipline_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BFESparkResponse::set_has_pipline_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BFESparkResponse::clear_has_pipline_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BFESparkResponse::clear_pipline_token() {
  if (pipline_token_ != &::google::protobuf::internal::kEmptyString) {
    pipline_token_->clear();
  }
  clear_has_pipline_token();
}
inline const ::std::string& BFESparkResponse::pipline_token() const {
  return *pipline_token_;
}
inline void BFESparkResponse::set_pipline_token(const ::std::string& value) {
  set_has_pipline_token();
  if (pipline_token_ == &::google::protobuf::internal::kEmptyString) {
    pipline_token_ = new ::std::string;
  }
  pipline_token_->assign(value);
}
inline void BFESparkResponse::set_pipline_token(const char* value) {
  set_has_pipline_token();
  if (pipline_token_ == &::google::protobuf::internal::kEmptyString) {
    pipline_token_ = new ::std::string;
  }
  pipline_token_->assign(value);
}
inline void BFESparkResponse::set_pipline_token(const char* value, size_t size) {
  set_has_pipline_token();
  if (pipline_token_ == &::google::protobuf::internal::kEmptyString) {
    pipline_token_ = new ::std::string;
  }
  pipline_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFESparkResponse::mutable_pipline_token() {
  set_has_pipline_token();
  if (pipline_token_ == &::google::protobuf::internal::kEmptyString) {
    pipline_token_ = new ::std::string;
  }
  return pipline_token_;
}
inline ::std::string* BFESparkResponse::release_pipline_token() {
  clear_has_pipline_token();
  if (pipline_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pipline_token_;
    pipline_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string failure_reason = 2;
inline bool BFESparkResponse::has_failure_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BFESparkResponse::set_has_failure_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BFESparkResponse::clear_has_failure_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BFESparkResponse::clear_failure_reason() {
  if (failure_reason_ != &::google::protobuf::internal::kEmptyString) {
    failure_reason_->clear();
  }
  clear_has_failure_reason();
}
inline const ::std::string& BFESparkResponse::failure_reason() const {
  return *failure_reason_;
}
inline void BFESparkResponse::set_failure_reason(const ::std::string& value) {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  failure_reason_->assign(value);
}
inline void BFESparkResponse::set_failure_reason(const char* value) {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  failure_reason_->assign(value);
}
inline void BFESparkResponse::set_failure_reason(const char* value, size_t size) {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  failure_reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFESparkResponse::mutable_failure_reason() {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  return failure_reason_;
}
inline ::std::string* BFESparkResponse::release_failure_reason() {
  clear_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = failure_reason_;
    failure_reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool response_bool = 3;
inline bool BFESparkResponse::has_response_bool() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BFESparkResponse::set_has_response_bool() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BFESparkResponse::clear_has_response_bool() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BFESparkResponse::clear_response_bool() {
  response_bool_ = false;
  clear_has_response_bool();
}
inline bool BFESparkResponse::response_bool() const {
  return response_bool_;
}
inline void BFESparkResponse::set_response_bool(bool value) {
  set_has_response_bool();
  response_bool_ = value;
}

// optional int32 response_int = 4;
inline bool BFESparkResponse::has_response_int() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BFESparkResponse::set_has_response_int() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BFESparkResponse::clear_has_response_int() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BFESparkResponse::clear_response_int() {
  response_int_ = 0;
  clear_has_response_int();
}
inline ::google::protobuf::int32 BFESparkResponse::response_int() const {
  return response_int_;
}
inline void BFESparkResponse::set_response_int(::google::protobuf::int32 value) {
  set_has_response_int();
  response_int_ = value;
}

// optional float response_float = 5;
inline bool BFESparkResponse::has_response_float() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BFESparkResponse::set_has_response_float() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BFESparkResponse::clear_has_response_float() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BFESparkResponse::clear_response_float() {
  response_float_ = 0;
  clear_has_response_float();
}
inline float BFESparkResponse::response_float() const {
  return response_float_;
}
inline void BFESparkResponse::set_response_float(float value) {
  set_has_response_float();
  response_float_ = value;
}

// optional bytes response_bytes = 6;
inline bool BFESparkResponse::has_response_bytes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BFESparkResponse::set_has_response_bytes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BFESparkResponse::clear_has_response_bytes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BFESparkResponse::clear_response_bytes() {
  if (response_bytes_ != &::google::protobuf::internal::kEmptyString) {
    response_bytes_->clear();
  }
  clear_has_response_bytes();
}
inline const ::std::string& BFESparkResponse::response_bytes() const {
  return *response_bytes_;
}
inline void BFESparkResponse::set_response_bytes(const ::std::string& value) {
  set_has_response_bytes();
  if (response_bytes_ == &::google::protobuf::internal::kEmptyString) {
    response_bytes_ = new ::std::string;
  }
  response_bytes_->assign(value);
}
inline void BFESparkResponse::set_response_bytes(const char* value) {
  set_has_response_bytes();
  if (response_bytes_ == &::google::protobuf::internal::kEmptyString) {
    response_bytes_ = new ::std::string;
  }
  response_bytes_->assign(value);
}
inline void BFESparkResponse::set_response_bytes(const void* value, size_t size) {
  set_has_response_bytes();
  if (response_bytes_ == &::google::protobuf::internal::kEmptyString) {
    response_bytes_ = new ::std::string;
  }
  response_bytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFESparkResponse::mutable_response_bytes() {
  set_has_response_bytes();
  if (response_bytes_ == &::google::protobuf::internal::kEmptyString) {
    response_bytes_ = new ::std::string;
  }
  return response_bytes_;
}
inline ::std::string* BFESparkResponse::release_response_bytes() {
  clear_has_response_bytes();
  if (response_bytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_bytes_;
    response_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BFEInfoQueryRequest

// required string auth_token = 1;
inline bool BFEInfoQueryRequest::has_auth_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BFEInfoQueryRequest::set_has_auth_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BFEInfoQueryRequest::clear_has_auth_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BFEInfoQueryRequest::clear_auth_token() {
  if (auth_token_ != &::google::protobuf::internal::kEmptyString) {
    auth_token_->clear();
  }
  clear_has_auth_token();
}
inline const ::std::string& BFEInfoQueryRequest::auth_token() const {
  return *auth_token_;
}
inline void BFEInfoQueryRequest::set_auth_token(const ::std::string& value) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(value);
}
inline void BFEInfoQueryRequest::set_auth_token(const char* value) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(value);
}
inline void BFEInfoQueryRequest::set_auth_token(const char* value, size_t size) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFEInfoQueryRequest::mutable_auth_token() {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  return auth_token_;
}
inline ::std::string* BFEInfoQueryRequest::release_auth_token() {
  clear_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_token_;
    auth_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BFEInfoQueryResponse

// optional string failure_reason = 1;
inline bool BFEInfoQueryResponse::has_failure_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BFEInfoQueryResponse::set_has_failure_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BFEInfoQueryResponse::clear_has_failure_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BFEInfoQueryResponse::clear_failure_reason() {
  if (failure_reason_ != &::google::protobuf::internal::kEmptyString) {
    failure_reason_->clear();
  }
  clear_has_failure_reason();
}
inline const ::std::string& BFEInfoQueryResponse::failure_reason() const {
  return *failure_reason_;
}
inline void BFEInfoQueryResponse::set_failure_reason(const ::std::string& value) {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  failure_reason_->assign(value);
}
inline void BFEInfoQueryResponse::set_failure_reason(const char* value) {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  failure_reason_->assign(value);
}
inline void BFEInfoQueryResponse::set_failure_reason(const char* value, size_t size) {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  failure_reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFEInfoQueryResponse::mutable_failure_reason() {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  return failure_reason_;
}
inline ::std::string* BFEInfoQueryResponse::release_failure_reason() {
  clear_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = failure_reason_;
    failure_reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string blaze_response = 2;
inline bool BFEInfoQueryResponse::has_blaze_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BFEInfoQueryResponse::set_has_blaze_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BFEInfoQueryResponse::clear_has_blaze_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BFEInfoQueryResponse::clear_blaze_response() {
  if (blaze_response_ != &::google::protobuf::internal::kEmptyString) {
    blaze_response_->clear();
  }
  clear_has_blaze_response();
}
inline const ::std::string& BFEInfoQueryResponse::blaze_response() const {
  return *blaze_response_;
}
inline void BFEInfoQueryResponse::set_blaze_response(const ::std::string& value) {
  set_has_blaze_response();
  if (blaze_response_ == &::google::protobuf::internal::kEmptyString) {
    blaze_response_ = new ::std::string;
  }
  blaze_response_->assign(value);
}
inline void BFEInfoQueryResponse::set_blaze_response(const char* value) {
  set_has_blaze_response();
  if (blaze_response_ == &::google::protobuf::internal::kEmptyString) {
    blaze_response_ = new ::std::string;
  }
  blaze_response_->assign(value);
}
inline void BFEInfoQueryResponse::set_blaze_response(const char* value, size_t size) {
  set_has_blaze_response();
  if (blaze_response_ == &::google::protobuf::internal::kEmptyString) {
    blaze_response_ = new ::std::string;
  }
  blaze_response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFEInfoQueryResponse::mutable_blaze_response() {
  set_has_blaze_response();
  if (blaze_response_ == &::google::protobuf::internal::kEmptyString) {
    blaze_response_ = new ::std::string;
  }
  return blaze_response_;
}
inline ::std::string* BFEInfoQueryResponse::release_blaze_response() {
  clear_has_blaze_response();
  if (blaze_response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = blaze_response_;
    blaze_response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Repository

// optional string repo_uuid = 1;
inline bool Repository::has_repo_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Repository::set_has_repo_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Repository::clear_has_repo_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Repository::clear_repo_uuid() {
  if (repo_uuid_ != &::google::protobuf::internal::kEmptyString) {
    repo_uuid_->clear();
  }
  clear_has_repo_uuid();
}
inline const ::std::string& Repository::repo_uuid() const {
  return *repo_uuid_;
}
inline void Repository::set_repo_uuid(const ::std::string& value) {
  set_has_repo_uuid();
  if (repo_uuid_ == &::google::protobuf::internal::kEmptyString) {
    repo_uuid_ = new ::std::string;
  }
  repo_uuid_->assign(value);
}
inline void Repository::set_repo_uuid(const char* value) {
  set_has_repo_uuid();
  if (repo_uuid_ == &::google::protobuf::internal::kEmptyString) {
    repo_uuid_ = new ::std::string;
  }
  repo_uuid_->assign(value);
}
inline void Repository::set_repo_uuid(const char* value, size_t size) {
  set_has_repo_uuid();
  if (repo_uuid_ == &::google::protobuf::internal::kEmptyString) {
    repo_uuid_ = new ::std::string;
  }
  repo_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Repository::mutable_repo_uuid() {
  set_has_repo_uuid();
  if (repo_uuid_ == &::google::protobuf::internal::kEmptyString) {
    repo_uuid_ = new ::std::string;
  }
  return repo_uuid_;
}
inline ::std::string* Repository::release_repo_uuid() {
  clear_has_repo_uuid();
  if (repo_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = repo_uuid_;
    repo_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Thilenius.BFEProtos.Revision revisions = 2;
inline int Repository::revisions_size() const {
  return revisions_.size();
}
inline void Repository::clear_revisions() {
  revisions_.Clear();
}
inline const ::Thilenius::BFEProtos::Revision& Repository::revisions(int index) const {
  return revisions_.Get(index);
}
inline ::Thilenius::BFEProtos::Revision* Repository::mutable_revisions(int index) {
  return revisions_.Mutable(index);
}
inline ::Thilenius::BFEProtos::Revision* Repository::add_revisions() {
  return revisions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::Revision >&
Repository::revisions() const {
  return revisions_;
}
inline ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::Revision >*
Repository::mutable_revisions() {
  return &revisions_;
}

// -------------------------------------------------------------------

// Revision

// optional string comment = 1;
inline bool Revision::has_comment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Revision::set_has_comment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Revision::clear_has_comment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Revision::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Revision::comment() const {
  return *comment_;
}
inline void Revision::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Revision::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Revision::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Revision::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* Revision::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 2;
inline bool Revision::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Revision::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Revision::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Revision::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& Revision::timestamp() const {
  return *timestamp_;
}
inline void Revision::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void Revision::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void Revision::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Revision::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* Revision::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Thilenius.BFEProtos.FileDelta file_deltas = 3;
inline int Revision::file_deltas_size() const {
  return file_deltas_.size();
}
inline void Revision::clear_file_deltas() {
  file_deltas_.Clear();
}
inline const ::Thilenius::BFEProtos::FileDelta& Revision::file_deltas(int index) const {
  return file_deltas_.Get(index);
}
inline ::Thilenius::BFEProtos::FileDelta* Revision::mutable_file_deltas(int index) {
  return file_deltas_.Mutable(index);
}
inline ::Thilenius::BFEProtos::FileDelta* Revision::add_file_deltas() {
  return file_deltas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::FileDelta >&
Revision::file_deltas() const {
  return file_deltas_;
}
inline ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::FileDelta >*
Revision::mutable_file_deltas() {
  return &file_deltas_;
}

// -------------------------------------------------------------------

// FileDelta

// required string path = 1;
inline bool FileDelta::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileDelta::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileDelta::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileDelta::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& FileDelta::path() const {
  return *path_;
}
inline void FileDelta::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FileDelta::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FileDelta::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileDelta::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* FileDelta::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .Thilenius.BFEProtos.FileDelta.ChangeType change_type = 2;
inline bool FileDelta::has_change_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileDelta::set_has_change_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileDelta::clear_has_change_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileDelta::clear_change_type() {
  change_type_ = 1;
  clear_has_change_type();
}
inline ::Thilenius::BFEProtos::FileDelta_ChangeType FileDelta::change_type() const {
  return static_cast< ::Thilenius::BFEProtos::FileDelta_ChangeType >(change_type_);
}
inline void FileDelta::set_change_type(::Thilenius::BFEProtos::FileDelta_ChangeType value) {
  GOOGLE_DCHECK(::Thilenius::BFEProtos::FileDelta_ChangeType_IsValid(value));
  set_has_change_type();
  change_type_ = value;
}

// repeated .Thilenius.BFEProtos.LexicalDelta lexical_deltas = 3;
inline int FileDelta::lexical_deltas_size() const {
  return lexical_deltas_.size();
}
inline void FileDelta::clear_lexical_deltas() {
  lexical_deltas_.Clear();
}
inline const ::Thilenius::BFEProtos::LexicalDelta& FileDelta::lexical_deltas(int index) const {
  return lexical_deltas_.Get(index);
}
inline ::Thilenius::BFEProtos::LexicalDelta* FileDelta::mutable_lexical_deltas(int index) {
  return lexical_deltas_.Mutable(index);
}
inline ::Thilenius::BFEProtos::LexicalDelta* FileDelta::add_lexical_deltas() {
  return lexical_deltas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::LexicalDelta >&
FileDelta::lexical_deltas() const {
  return lexical_deltas_;
}
inline ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::LexicalDelta >*
FileDelta::mutable_lexical_deltas() {
  return &lexical_deltas_;
}

// -------------------------------------------------------------------

// LexicalDelta

// required int32 from_begin = 1;
inline bool LexicalDelta::has_from_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LexicalDelta::set_has_from_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LexicalDelta::clear_has_from_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LexicalDelta::clear_from_begin() {
  from_begin_ = 0;
  clear_has_from_begin();
}
inline ::google::protobuf::int32 LexicalDelta::from_begin() const {
  return from_begin_;
}
inline void LexicalDelta::set_from_begin(::google::protobuf::int32 value) {
  set_has_from_begin();
  from_begin_ = value;
}

// required int32 from_end = 2;
inline bool LexicalDelta::has_from_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LexicalDelta::set_has_from_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LexicalDelta::clear_has_from_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LexicalDelta::clear_from_end() {
  from_end_ = 0;
  clear_has_from_end();
}
inline ::google::protobuf::int32 LexicalDelta::from_end() const {
  return from_end_;
}
inline void LexicalDelta::set_from_end(::google::protobuf::int32 value) {
  set_has_from_end();
  from_end_ = value;
}

// required int32 to_begin = 3;
inline bool LexicalDelta::has_to_begin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LexicalDelta::set_has_to_begin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LexicalDelta::clear_has_to_begin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LexicalDelta::clear_to_begin() {
  to_begin_ = 0;
  clear_has_to_begin();
}
inline ::google::protobuf::int32 LexicalDelta::to_begin() const {
  return to_begin_;
}
inline void LexicalDelta::set_to_begin(::google::protobuf::int32 value) {
  set_has_to_begin();
  to_begin_ = value;
}

// required int32 to_end = 4;
inline bool LexicalDelta::has_to_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LexicalDelta::set_has_to_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LexicalDelta::clear_has_to_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LexicalDelta::clear_to_end() {
  to_end_ = 0;
  clear_has_to_end();
}
inline ::google::protobuf::int32 LexicalDelta::to_end() const {
  return to_end_;
}
inline void LexicalDelta::set_to_end(::google::protobuf::int32 value) {
  set_has_to_end();
  to_end_ = value;
}

// optional string text = 5;
inline bool LexicalDelta::has_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LexicalDelta::set_has_text() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LexicalDelta::clear_has_text() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LexicalDelta::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& LexicalDelta::text() const {
  return *text_;
}
inline void LexicalDelta::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void LexicalDelta::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void LexicalDelta::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LexicalDelta::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* LexicalDelta::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BFETextFile

// optional string name = 1;
inline bool BFETextFile::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BFETextFile::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BFETextFile::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BFETextFile::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BFETextFile::name() const {
  return *name_;
}
inline void BFETextFile::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BFETextFile::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BFETextFile::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFETextFile::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* BFETextFile::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string extension = 2;
inline bool BFETextFile::has_extension() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BFETextFile::set_has_extension() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BFETextFile::clear_has_extension() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BFETextFile::clear_extension() {
  if (extension_ != &::google::protobuf::internal::kEmptyString) {
    extension_->clear();
  }
  clear_has_extension();
}
inline const ::std::string& BFETextFile::extension() const {
  return *extension_;
}
inline void BFETextFile::set_extension(const ::std::string& value) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    extension_ = new ::std::string;
  }
  extension_->assign(value);
}
inline void BFETextFile::set_extension(const char* value) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    extension_ = new ::std::string;
  }
  extension_->assign(value);
}
inline void BFETextFile::set_extension(const char* value, size_t size) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    extension_ = new ::std::string;
  }
  extension_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFETextFile::mutable_extension() {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    extension_ = new ::std::string;
  }
  return extension_;
}
inline ::std::string* BFETextFile::release_extension() {
  clear_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extension_;
    extension_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string modify_date = 3;
inline bool BFETextFile::has_modify_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BFETextFile::set_has_modify_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BFETextFile::clear_has_modify_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BFETextFile::clear_modify_date() {
  if (modify_date_ != &::google::protobuf::internal::kEmptyString) {
    modify_date_->clear();
  }
  clear_has_modify_date();
}
inline const ::std::string& BFETextFile::modify_date() const {
  return *modify_date_;
}
inline void BFETextFile::set_modify_date(const ::std::string& value) {
  set_has_modify_date();
  if (modify_date_ == &::google::protobuf::internal::kEmptyString) {
    modify_date_ = new ::std::string;
  }
  modify_date_->assign(value);
}
inline void BFETextFile::set_modify_date(const char* value) {
  set_has_modify_date();
  if (modify_date_ == &::google::protobuf::internal::kEmptyString) {
    modify_date_ = new ::std::string;
  }
  modify_date_->assign(value);
}
inline void BFETextFile::set_modify_date(const char* value, size_t size) {
  set_has_modify_date();
  if (modify_date_ == &::google::protobuf::internal::kEmptyString) {
    modify_date_ = new ::std::string;
  }
  modify_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFETextFile::mutable_modify_date() {
  set_has_modify_date();
  if (modify_date_ == &::google::protobuf::internal::kEmptyString) {
    modify_date_ = new ::std::string;
  }
  return modify_date_;
}
inline ::std::string* BFETextFile::release_modify_date() {
  clear_has_modify_date();
  if (modify_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modify_date_;
    modify_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contents = 4;
inline bool BFETextFile::has_contents() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BFETextFile::set_has_contents() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BFETextFile::clear_has_contents() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BFETextFile::clear_contents() {
  if (contents_ != &::google::protobuf::internal::kEmptyString) {
    contents_->clear();
  }
  clear_has_contents();
}
inline const ::std::string& BFETextFile::contents() const {
  return *contents_;
}
inline void BFETextFile::set_contents(const ::std::string& value) {
  set_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    contents_ = new ::std::string;
  }
  contents_->assign(value);
}
inline void BFETextFile::set_contents(const char* value) {
  set_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    contents_ = new ::std::string;
  }
  contents_->assign(value);
}
inline void BFETextFile::set_contents(const char* value, size_t size) {
  set_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    contents_ = new ::std::string;
  }
  contents_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFETextFile::mutable_contents() {
  set_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    contents_ = new ::std::string;
  }
  return contents_;
}
inline ::std::string* BFETextFile::release_contents() {
  clear_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contents_;
    contents_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BFECodeSubmitRequest

// required string auth_token = 1;
inline bool BFECodeSubmitRequest::has_auth_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BFECodeSubmitRequest::set_has_auth_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BFECodeSubmitRequest::clear_has_auth_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BFECodeSubmitRequest::clear_auth_token() {
  if (auth_token_ != &::google::protobuf::internal::kEmptyString) {
    auth_token_->clear();
  }
  clear_has_auth_token();
}
inline const ::std::string& BFECodeSubmitRequest::auth_token() const {
  return *auth_token_;
}
inline void BFECodeSubmitRequest::set_auth_token(const ::std::string& value) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(value);
}
inline void BFECodeSubmitRequest::set_auth_token(const char* value) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(value);
}
inline void BFECodeSubmitRequest::set_auth_token(const char* value, size_t size) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFECodeSubmitRequest::mutable_auth_token() {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  return auth_token_;
}
inline ::std::string* BFECodeSubmitRequest::release_auth_token() {
  clear_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_token_;
    auth_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Thilenius.BFEProtos.BFETextFile code_files = 2;
inline int BFECodeSubmitRequest::code_files_size() const {
  return code_files_.size();
}
inline void BFECodeSubmitRequest::clear_code_files() {
  code_files_.Clear();
}
inline const ::Thilenius::BFEProtos::BFETextFile& BFECodeSubmitRequest::code_files(int index) const {
  return code_files_.Get(index);
}
inline ::Thilenius::BFEProtos::BFETextFile* BFECodeSubmitRequest::mutable_code_files(int index) {
  return code_files_.Mutable(index);
}
inline ::Thilenius::BFEProtos::BFETextFile* BFECodeSubmitRequest::add_code_files() {
  return code_files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::BFETextFile >&
BFECodeSubmitRequest::code_files() const {
  return code_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::Thilenius::BFEProtos::BFETextFile >*
BFECodeSubmitRequest::mutable_code_files() {
  return &code_files_;
}

// -------------------------------------------------------------------

// BFECodeSubmitResponse

// optional string failure_reason = 1;
inline bool BFECodeSubmitResponse::has_failure_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BFECodeSubmitResponse::set_has_failure_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BFECodeSubmitResponse::clear_has_failure_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BFECodeSubmitResponse::clear_failure_reason() {
  if (failure_reason_ != &::google::protobuf::internal::kEmptyString) {
    failure_reason_->clear();
  }
  clear_has_failure_reason();
}
inline const ::std::string& BFECodeSubmitResponse::failure_reason() const {
  return *failure_reason_;
}
inline void BFECodeSubmitResponse::set_failure_reason(const ::std::string& value) {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  failure_reason_->assign(value);
}
inline void BFECodeSubmitResponse::set_failure_reason(const char* value) {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  failure_reason_->assign(value);
}
inline void BFECodeSubmitResponse::set_failure_reason(const char* value, size_t size) {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  failure_reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BFECodeSubmitResponse::mutable_failure_reason() {
  set_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    failure_reason_ = new ::std::string;
  }
  return failure_reason_;
}
inline ::std::string* BFECodeSubmitResponse::release_failure_reason() {
  clear_has_failure_reason();
  if (failure_reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = failure_reason_;
    failure_reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace BFEProtos
}  // namespace Thilenius

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BFEProtos_2eproto__INCLUDED
